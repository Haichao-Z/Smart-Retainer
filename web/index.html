<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Retainer - 3D Head Tracking v2.1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .version {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #connectBtn.connected {
            background: rgba(76, 175, 80, 0.5);
        }

        #status {
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            font-size: 14px;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            z-index: 5;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info-label {
            font-weight: 600;
            opacity: 0.8;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .quaternion {
            font-size: 11px;
            color: #64b5f6;
        }

        #render-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .calibration-info {
            font-size: 11px;
            color: #ffeb3b;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 235, 59, 0.1);
            border-radius: 4px;
        }

        .coordinate-info {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            max-width: 250px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ü¶∑ Smart Retainer - Real-Time Head Tracking</h1>
            <div class="version">v2.2 - Zero-point calibration with angle reset</div>
            <div id="controls">
                <button id="connectBtn">Connect to Device</button>
                <button id="resetBtn" disabled>Reset Orientation</button>
                <button id="calibrateBtn" disabled>Set Zero Point</button>
                <div id="status" class="pulse">‚ö™ Disconnected</div>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="render-canvas"></canvas>
            
            <div id="info-panel">
                <h3 style="margin-bottom: 15px;">üìä Orientation Data</h3>
                <div class="info-row">
                    <span class="info-label">Roll (X-axis):</span>
                    <span class="info-value" id="roll">0.0¬∞</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Pitch (Y-axis):</span>
                    <span class="info-value" id="pitch">0.0¬∞</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Yaw (Z-axis):</span>
                    <span class="info-value" id="yaw">0.0¬∞</span>
                </div>
                <hr style="margin: 15px 0; opacity: 0.3;">
                <div class="info-row quaternion">
                    <span class="info-label">Quaternion:</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">w:</span>
                    <span class="info-value" id="qw">1.000</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">x:</span>
                    <span class="info-value" id="qx">0.000</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">y:</span>
                    <span class="info-value" id="qy">0.000</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">z:</span>
                    <span class="info-value" id="qz">0.000</span>
                </div>
                <hr style="margin: 15px 0; opacity: 0.3;">
                <div class="info-row">
                    <span class="info-label">Update Rate:</span>
                    <span class="info-value" id="fps">0 Hz</span>
                </div>
                <div class="calibration-info">
                    üí° Press "Set Zero Point" to calibrate reference orientation. 
                    <span id="calibration-status" style="display: block; margin-top: 5px; color: #ff9800;">
                        Status: Not Calibrated
                    </span>
                </div>
            </div>

            <div class="coordinate-info">
                <strong>üìê Coordinate System:</strong><br>
                ‚Ä¢ X-axis (Red): Right<br>
                ‚Ä¢ Y-axis (Green): Up<br>
                ‚Ä¢ Z-axis (Blue): Forward<br>
                <br>
                <strong>Rotations:</strong><br>
                ‚Ä¢ Roll: Tilt left/right<br>
                ‚Ä¢ Pitch: Nod up/down<br>
                ‚Ä¢ Yaw: Turn left/right
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // BLE Service UUIDs
        const IMU_SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
        const QUATERNION_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef1';
        const EULER_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef2';
        const CONTROL_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef3';

        // BLE variables
        let bleDevice = null;
        let bleServer = null;
        let quaternionCharacteristic = null;
        let eulerCharacteristic = null;
        let controlCharacteristic = null;

        // Three.js variables
        let scene, camera, renderer, retainerModel;
        let animationId = null;

        // Data variables
        let currentQuaternion = { w: 1, x: 0, y: 0, z: 0 };
        let lastUpdateTime = 0;
        let updateCount = 0;
        let fps = 0;
        
        // Zero-point calibration
        let zeroQuaternion = null;  // Reference quaternion for zero point
        let isCalibrated = false;

        // UI Elements
        const connectBtn = document.getElementById('connectBtn');
        const resetBtn = document.getElementById('resetBtn');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const statusDiv = document.getElementById('status');

        // Initialize Three.js scene
        function initThreeJS() {
            const canvas = document.getElementById('render-canvas');
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 8);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0x6366f1, 0.4);
            backLight.position.set(-5, 3, -5);
            scene.add(backLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(0, -5, 0);
            scene.add(fillLight);

            createRetainerModel();

            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            gridHelper.position.y = -3;
            scene.add(gridHelper);

            const axesHelper = new THREE.AxesHelper(2.5);
            scene.add(axesHelper);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createRetainerModel() {
            const group = new THREE.Group();

            const toothMaterial = new THREE.MeshStandardMaterial({
                color: 0xfff8e7,
                roughness: 0.3,
                metalness: 0.1,
                emissive: 0xfff8e7,
                emissiveIntensity: 0.05
            });

            const retainerMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.4,
                roughness: 0.2,
                metalness: 0.3
            });

            const wireMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.3,
                metalness: 0.8
            });

            const upperArchCurve = new THREE.EllipseCurve(
                0, 0, 1.2, 0.9, 0, Math.PI, false, 0
            );

            const upperTeethPositions = [
                { x: -0.15, z: 1.0, width: 0.25, height: 0.35 },
                { x: 0.15, z: 1.0, width: 0.25, height: 0.35 },
                { x: -0.45, z: 0.98, width: 0.22, height: 0.32 },
                { x: 0.45, z: 0.98, width: 0.22, height: 0.32 },
                { x: -0.75, z: 0.92, width: 0.24, height: 0.38 },
                { x: 0.75, z: 0.92, width: 0.24, height: 0.38 },
                { x: -1.0, z: 0.75, width: 0.26, height: 0.32 },
                { x: 1.0, z: 0.75, width: 0.26, height: 0.32 },
                { x: -1.15, z: 0.5, width: 0.26, height: 0.32 },
                { x: 1.15, z: 0.5, width: 0.26, height: 0.32 },
                { x: -1.2, z: 0.2, width: 0.28, height: 0.30 },
                { x: 1.2, z: 0.2, width: 0.28, height: 0.30 }
            ];

            upperTeethPositions.forEach(pos => {
                const tooth = createTooth(pos.width, pos.height, toothMaterial);
                tooth.position.set(pos.x, 0.3, pos.z);
                group.add(tooth);
            });

            const upperPlateGeometry = new THREE.ExtrudeGeometry(
                new THREE.Shape(upperArchCurve.getPoints(50)),
                {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 3
                }
            );
            const upperPlate = new THREE.Mesh(upperPlateGeometry, retainerMaterial);
            upperPlate.rotation.x = -Math.PI / 2;
            upperPlate.position.y = 0.15;
            group.add(upperPlate);

            const lowerArchCurve = new THREE.EllipseCurve(
                0, 0, 1.1, 0.85, 0, Math.PI, false, 0
            );

            const lowerTeethPositions = [
                { x: -0.12, z: 0.95, width: 0.20, height: 0.30 },
                { x: 0.12, z: 0.95, width: 0.20, height: 0.30 },
                { x: -0.38, z: 0.93, width: 0.21, height: 0.30 },
                { x: 0.38, z: 0.93, width: 0.21, height: 0.30 },
                { x: -0.68, z: 0.87, width: 0.22, height: 0.35 },
                { x: 0.68, z: 0.87, width: 0.22, height: 0.35 },
                { x: -0.92, z: 0.70, width: 0.24, height: 0.30 },
                { x: 0.92, z: 0.70, width: 0.24, height: 0.30 },
                { x: -1.05, z: 0.48, width: 0.24, height: 0.30 },
                { x: 1.05, z: 0.48, width: 0.24, height: 0.30 },
                { x: -1.1, z: 0.2, width: 0.26, height: 0.28 },
                { x: 1.1, z: 0.2, width: 0.26, height: 0.28 }
            ];

            lowerTeethPositions.forEach(pos => {
                const tooth = createTooth(pos.width, pos.height, toothMaterial);
                tooth.position.set(pos.x, -0.5, pos.z);
                group.add(tooth);
            });

            const lowerPlateGeometry = new THREE.ExtrudeGeometry(
                new THREE.Shape(lowerArchCurve.getPoints(50)),
                {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 3
                }
            );
            const lowerPlate = new THREE.Mesh(lowerPlateGeometry, retainerMaterial);
            lowerPlate.rotation.x = -Math.PI / 2;
            lowerPlate.position.y = -0.65;
            group.add(lowerPlate);

            const wirePoints = [];
            const wireSegments = 50;
            for (let i = 0; i <= wireSegments; i++) {
                const t = i / wireSegments;
                const angle = Math.PI * t;
                const x = Math.cos(angle) * 1.15;
                const z = Math.sin(angle) * 0.88;
                wirePoints.push(new THREE.Vector3(x, 0.45, z));
            }
            const wireGeometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(wirePoints),
                64, 0.015, 8, false
            );
            const wire = new THREE.Mesh(wireGeometry, wireMaterial);
            group.add(wire);

            const arrowGeometry = new THREE.ConeGeometry(0.12, 0.4, 8);
            const arrowMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                emissive: 0xff0000,
                emissiveIntensity: 0.4
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(0, 0.3, 1.5);
            arrow.rotation.x = Math.PI / 2;
            group.add(arrow);

            const modelAxes = new THREE.AxesHelper(1.8);
            group.add(modelAxes);

            retainerModel = group;
            scene.add(retainerModel);
        }

        function createTooth(width, height, material) {
            const toothGroup = new THREE.Group();

            const crownGeometry = new THREE.BoxGeometry(width, height, 0.25);
            const crown = new THREE.Mesh(crownGeometry, material);
            crown.castShadow = true;
            toothGroup.add(crown);

            const topGeometry = new THREE.SphereGeometry(
                width * 0.5, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2
            );
            const top = new THREE.Mesh(topGeometry, material);
            top.position.y = height / 2;
            top.scale.set(1, 0.3, 0.6);
            toothGroup.add(top);

            return toothGroup;
        }

        function animate() {
            animationId = requestAnimationFrame(animate);

            const now = Date.now();
            if (now - lastUpdateTime >= 1000) {
                fps = updateCount;
                document.getElementById('fps').textContent = fps + ' Hz';
                updateCount = 0;
                lastUpdateTime = now;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        /**
         * Quaternion conjugate (inverse for unit quaternions)
         */
        function quaternionConjugate(q) {
            return { w: q.w, x: -q.x, y: -q.y, z: -q.z };
        }

        /**
         * Quaternion multiplication: q1 * q2
         */
        function quaternionMultiply(q1, q2) {
            return {
                w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
                x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
                y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
                z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
            };
        }

        /**
         * Apply zero-point calibration to quaternion
         * Returns: q_zero_inverse * q_current
         */
        function applyZeroPointCalibration(q) {
            if (!isCalibrated || !zeroQuaternion) {
                return q;
            }
            
            // Get inverse of zero quaternion
            const qZeroInv = quaternionConjugate(zeroQuaternion);
            
            // Apply correction: q_corrected = q_zero_inv * q_current
            return quaternionMultiply(qZeroInv, q);
        }

        /**
         * Set current orientation as zero point
         */
        function setZeroPoint(q) {
            zeroQuaternion = { w: q.w, x: q.x, y: q.y, z: q.z };
            isCalibrated = true;
            
            console.log('Zero point set:', zeroQuaternion);
            console.log('Euler angles will now be relative to this orientation');
            
            // Visual feedback
            statusDiv.textContent = 'üü¢ Connected (Calibrated ‚úì)';
            
            // Update calibration status
            const calibStatus = document.getElementById('calibration-status');
            if (calibStatus) {
                calibStatus.textContent = 'Status: Calibrated ‚úì';
                calibStatus.style.color = '#4caf50';
            }
            
            // Show notification
            showCalibrationNotification();
        }

        /**
         * Reset zero point calibration
         */
        function resetZeroPoint() {
            zeroQuaternion = null;
            isCalibrated = false;
            
            console.log('Zero point reset');
            
            // Update calibration status
            const calibStatus = document.getElementById('calibration-status');
            if (calibStatus) {
                calibStatus.textContent = 'Status: Not Calibrated';
                calibStatus.style.color = '#ff9800';
            }
            
            if (bleDevice && bleDevice.gatt.connected) {
                statusDiv.textContent = 'üü¢ Connected';
            }
        }

        /**
         * Show calibration success notification
         */
        function showCalibrationNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 175, 80, 0.95);
                color: white;
                padding: 30px 50px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            `;
            notification.innerHTML = `
                ‚úì Zero Point Set!<br>
                <span style="font-size: 14px; font-weight: normal;">Angles are now relative to this position</span>
            `;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transition = 'opacity 0.5s';
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 2000);
        }

        /**
         * Update retainer orientation from quaternion
         * Maps: set(q.x, q.z, -q.y, q.w)
         */
        function updateRetainerOrientation(q) {
            if (!retainerModel) return;
            retainerModel.quaternion.set(q.x, -q.y, q.z, q.w);
            updateCount++;
        }

        /**
         * Convert quaternion to Euler angles matching 3D model rotation
         * Based on the transformation: set(q.x, q.z, -q.y, q.w)
         */
        function quaternionToEulerForDisplay(q) {
            // Create Three.js quaternion with the same mapping as 3D model
            const threeQuat = new THREE.Quaternion(q.x, -q.y, q.z, q.w);
            
            // Convert to Euler angles (ZYX order)
            const euler = new THREE.Euler();
            euler.setFromQuaternion(threeQuat, 'ZYX');
            
            // Convert to degrees
            return {
                roll: euler.x * 180 / Math.PI,   // Rotation around X-axis
                pitch: euler.y * 180 / Math.PI,  // Rotation around Y-axis  
                yaw: euler.z * 180 / Math.PI     // Rotation around Z-axis
            };
        }

        // BLE Connection with improved reconnection support
        async function connectBLE() {
            try {
                statusDiv.textContent = 'üîµ Connecting...';
                statusDiv.classList.add('pulse');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'SmartRetainer' }],
                    optionalServices: [IMU_SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);

                bleServer = await bleDevice.gatt.connect();
                const service = await bleServer.getPrimaryService(IMU_SERVICE_UUID);

                quaternionCharacteristic = await service.getCharacteristic(QUATERNION_CHAR_UUID);
                eulerCharacteristic = await service.getCharacteristic(EULER_CHAR_UUID);
                controlCharacteristic = await service.getCharacteristic(CONTROL_CHAR_UUID);

                await quaternionCharacteristic.startNotifications();
                quaternionCharacteristic.addEventListener('characteristicvaluechanged', 
                    handleQuaternionData);

                await eulerCharacteristic.startNotifications();
                eulerCharacteristic.addEventListener('characteristicvaluechanged', 
                    handleEulerData);

                statusDiv.textContent = 'üü¢ Connected';
                statusDiv.classList.remove('pulse');
                connectBtn.textContent = 'Disconnect';
                connectBtn.classList.add('connected');
                resetBtn.disabled = false;
                calibrateBtn.disabled = false;

                console.log('BLE connected successfully');

            } catch (error) {
                console.error('BLE connection error:', error);
                statusDiv.textContent = 'üî¥ Connection Failed';
                statusDiv.classList.remove('pulse');
                
                // Clean up on error
                cleanupBLE();
                alert('Failed to connect: ' + error.message);
            }
        }

        function onDisconnected() {
            console.log('BLE disconnected');
            statusDiv.textContent = '‚ö™ Disconnected';
            statusDiv.classList.add('pulse');
            connectBtn.textContent = 'Connect to Device';
            connectBtn.classList.remove('connected');
            resetBtn.disabled = true;
            calibrateBtn.disabled = true;

            cleanupBLE();
        }

        function cleanupBLE() {
            // Remove event listeners before clearing references
            if (quaternionCharacteristic) {
                try {
                    quaternionCharacteristic.removeEventListener('characteristicvaluechanged', 
                        handleQuaternionData);
                } catch (e) {
                    console.warn('Error removing quaternion listener:', e);
                }
            }
            
            if (eulerCharacteristic) {
                try {
                    eulerCharacteristic.removeEventListener('characteristicvaluechanged', 
                        handleEulerData);
                } catch (e) {
                    console.warn('Error removing euler listener:', e);
                }
            }

            // Clear references
            quaternionCharacteristic = null;
            eulerCharacteristic = null;
            controlCharacteristic = null;
            bleServer = null;
            
            // Reset calibration on disconnect
            resetZeroPoint();
            
            // Don't clear bleDevice here - it's managed by browser
        }

        async function disconnectBLE() {
            if (bleDevice && bleDevice.gatt.connected) {
                try {
                    await bleDevice.gatt.disconnect();
                    console.log('Disconnected successfully');
                } catch (error) {
                    console.error('Error during disconnect:', error);
                }
            }
            // onDisconnected will be called automatically
        }

        function handleQuaternionData(event) {
            const value = event.target.value;
            
            const w = value.getFloat32(0, true);
            const x = value.getFloat32(4, true);
            const y = value.getFloat32(8, true);
            const z = value.getFloat32(12, true);

            // Store raw quaternion
            const rawQuaternion = { w, x, y, z };
            
            // Check if we need to set zero point
            if (window.setZeroOnNextPacket) {
                setZeroPoint(rawQuaternion);
                window.setZeroOnNextPacket = false;
            }
            
            // Apply zero-point calibration
            currentQuaternion = applyZeroPointCalibration(rawQuaternion);

            // Update 3D model with calibrated quaternion
            updateRetainerOrientation(currentQuaternion);

            // Calculate and display Euler angles that match 3D rotation
            const euler = quaternionToEulerForDisplay(currentQuaternion);
            
            document.getElementById('roll').textContent = euler.roll.toFixed(1) + '¬∞';
            document.getElementById('pitch').textContent = euler.pitch.toFixed(1) + '¬∞';
            document.getElementById('yaw').textContent = euler.yaw.toFixed(1) + '¬∞';

            // Update quaternion display (show calibrated values)
            document.getElementById('qw').textContent = currentQuaternion.w.toFixed(3);
            document.getElementById('qx').textContent = currentQuaternion.x.toFixed(3);
            document.getElementById('qy').textContent = currentQuaternion.y.toFixed(3);
            document.getElementById('qz').textContent = currentQuaternion.z.toFixed(3);
        }

        function handleEulerData(event) {
            // This function can be empty since we calculate Euler from quaternion
            // But we keep it to maintain notification subscription
        }

        async function sendControlCommand(cmd) {
            if (!controlCharacteristic) {
                alert('Not connected to device');
                return;
            }

            try {
                const data = new Uint8Array([cmd]);
                await controlCharacteristic.writeValue(data);
                console.log('Control command sent:', cmd);
            } catch (error) {
                console.error('Failed to send command:', error);
                alert('Failed to send command: ' + error.message);
            }
        }

        // Event listeners
        connectBtn.addEventListener('click', () => {
            if (bleDevice && bleDevice.gatt.connected) {
                disconnectBLE();
            } else {
                connectBLE();
            }
        });

        resetBtn.addEventListener('click', () => {
            if (confirm('Reset zero point calibration?')) {
                // Reset local calibration
                resetZeroPoint();
                
                // Send reset command to device
                sendControlCommand(0x03); // BLE_IMU_CMD_RESET
                
                console.log('Zero point calibration reset');
            }
        });

        calibrateBtn.addEventListener('click', async () => {
            if (!currentQuaternion) {
                alert('No orientation data available');
                return;
            }
            
            // Send command to device first
            await sendControlCommand(0x05); // BLE_IMU_CMD_SET_ZERO
            
            // Wait a bit for device to process
            setTimeout(() => {
                // Set zero point in web app (using the last received raw quaternion)
                // We need to get the raw quaternion before calibration was applied
                // For now, we'll trigger recalibration on next data packet
                
                // Flag to set zero on next packet
                window.setZeroOnNextPacket = true;
                
                console.log('Zero point calibration initiated');
            }, 100);
        });

        // Check browser support
        if (!navigator.bluetooth) {
            alert('Web Bluetooth API is not supported in this browser. Please use Chrome, Edge, or Opera.');
            connectBtn.disabled = true;
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initThreeJS();
            console.log('Smart Retainer Visualizer v2.2 initialized');
            console.log('Features:');
            console.log('- Euler angles match 3D model rotation');
            console.log('- BLE reconnection support');
            console.log('- Zero-point calibration with angle reset');
        });
    </script>
</body>
</html>