<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Retainer - 3D Head Tracking v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #header {
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .version {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #connectBtn.connected {
            background: rgba(76, 175, 80, 0.5);
        }

        #status {
            padding: 8px 16px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            font-size: 14px;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            min-width: 280px;
            z-index: 5;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .info-label {
            font-weight: 600;
            opacity: 0.8;
        }

        .info-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .quaternion {
            font-size: 11px;
            color: #64b5f6;
        }

        #render-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .calibration-info {
            font-size: 11px;
            color: #ffeb3b;
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 235, 59, 0.1);
            border-radius: 4px;
        }

        .coordinate-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            max-width: 250px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ü¶∑ Smart Retainer - Real-Time Head Tracking</h1>
            <div class="version">v2.0 - Improved with Gyro Calibration & Coordinate Correction</div>
            <div id="controls">
                <button id="connectBtn">Connect to Device</button>
                <button id="resetBtn" disabled>Reset Orientation</button>
                <button id="calibrateBtn" disabled>Calibrate</button>
                <div id="status" class="pulse">‚ö™ Disconnected</div>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="render-canvas"></canvas>
            
            <div id="info-panel">
                <h3 style="margin-bottom: 15px;">üìä Orientation Data</h3>
                <div class="info-row">
                    <span class="info-label">Roll (X):</span>
                    <span class="info-value" id="roll">0.0¬∞</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Pitch (Y):</span>
                    <span class="info-value" id="pitch">0.0¬∞</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Yaw (Z):</span>
                    <span class="info-value" id="yaw">0.0¬∞</span>
                </div>
                <hr style="margin: 15px 0; opacity: 0.3;">
                <div class="info-row quaternion">
                    <span class="info-label">Quaternion:</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">w:</span>
                    <span class="info-value" id="qw">1.000</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">x:</span>
                    <span class="info-value" id="qx">0.000</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">y:</span>
                    <span class="info-value" id="qy">0.000</span>
                </div>
                <div class="info-row quaternion">
                    <span class="info-label">z:</span>
                    <span class="info-value" id="qz">0.000</span>
                </div>
                <hr style="margin: 15px 0; opacity: 0.3;">
                <div class="info-row">
                    <span class="info-label">Update Rate:</span>
                    <span class="info-value" id="fps">0 Hz</span>
                </div>
                <div class="calibration-info">
                    üí° Device performs auto-calibration at startup. Keep stationary for 2 seconds after power-on.
                </div>
            </div>

            <div class="coordinate-info">
                <strong>üìê Coordinate System:</strong><br>
                ‚Ä¢ X-axis (Red): Right<br>
                ‚Ä¢ Y-axis (Green): Up<br>
                ‚Ä¢ Z-axis (Blue): Forward<br>
                <br>
                <strong>Rotations:</strong><br>
                ‚Ä¢ Roll: Rotation around X<br>
                ‚Ä¢ Pitch: Rotation around Y<br>
                ‚Ä¢ Yaw: Rotation around Z
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // BLE Service UUIDs (matching firmware)
        const IMU_SERVICE_UUID = '12345678-1234-5678-1234-56789abcdef0';
        const QUATERNION_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef1';
        const EULER_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef2';
        const CONTROL_CHAR_UUID = '12345678-1234-5678-1234-56789abcdef3';

        // BLE variables
        let bleDevice = null;
        let bleServer = null;
        let quaternionCharacteristic = null;
        let eulerCharacteristic = null;
        let controlCharacteristic = null;

        // Three.js variables
        let scene, camera, renderer, retainerModel;
        let animationId = null;

        // Data variables
        let currentQuaternion = { w: 1, x: 0, y: 0, z: 0 };
        let currentEuler = { roll: 0, pitch: 0, yaw: 0 };
        let lastUpdateTime = 0;
        let updateCount = 0;
        let fps = 0;

        // UI Elements
        const connectBtn = document.getElementById('connectBtn');
        const resetBtn = document.getElementById('resetBtn');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const statusDiv = document.getElementById('status');

        // Initialize Three.js scene
        function initThreeJS() {
            const canvas = document.getElementById('render-canvas');
            const container = document.getElementById('canvas-container');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 0, 8);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0x6366f1, 0.4);
            backLight.position.set(-5, 3, -5);
            scene.add(backLight);

            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(0, -5, 0);
            scene.add(fillLight);

            // Create retainer model
            createRetainerModel();

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            gridHelper.position.y = -3;
            scene.add(gridHelper);

            // Enhanced axes helper
            const axesHelper = new THREE.AxesHelper(2.5);
            scene.add(axesHelper);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();
        }

        // Create realistic dental retainer model
        function createRetainerModel() {
            const group = new THREE.Group();

            // Materials
            const toothMaterial = new THREE.MeshStandardMaterial({
                color: 0xfff8e7,
                roughness: 0.3,
                metalness: 0.1,
                emissive: 0xfff8e7,
                emissiveIntensity: 0.05
            });

            const retainerMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.4,
                roughness: 0.2,
                metalness: 0.3
            });

            const wireMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.3,
                metalness: 0.8
            });

            // Upper arch
            const upperArchCurve = new THREE.EllipseCurve(
                0, 0, 1.2, 0.9, 0, Math.PI, false, 0
            );

            // Create upper teeth
            const upperTeethPositions = [
                { x: -0.15, z: 1.0, width: 0.25, height: 0.35 },
                { x: 0.15, z: 1.0, width: 0.25, height: 0.35 },
                { x: -0.45, z: 0.98, width: 0.22, height: 0.32 },
                { x: 0.45, z: 0.98, width: 0.22, height: 0.32 },
                { x: -0.75, z: 0.92, width: 0.24, height: 0.38 },
                { x: 0.75, z: 0.92, width: 0.24, height: 0.38 },
                { x: -1.0, z: 0.75, width: 0.26, height: 0.32 },
                { x: 1.0, z: 0.75, width: 0.26, height: 0.32 },
                { x: -1.15, z: 0.5, width: 0.26, height: 0.32 },
                { x: 1.15, z: 0.5, width: 0.26, height: 0.32 },
                { x: -1.2, z: 0.2, width: 0.28, height: 0.30 },
                { x: 1.2, z: 0.2, width: 0.28, height: 0.30 }
            ];

            upperTeethPositions.forEach(pos => {
                const tooth = createTooth(pos.width, pos.height, toothMaterial);
                tooth.position.set(pos.x, 0.3, pos.z);
                group.add(tooth);
            });

            // Upper retainer plate
            const upperPlateGeometry = new THREE.ExtrudeGeometry(
                new THREE.Shape(upperArchCurve.getPoints(50)),
                {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 3
                }
            );
            const upperPlate = new THREE.Mesh(upperPlateGeometry, retainerMaterial);
            upperPlate.rotation.x = -Math.PI / 2;
            upperPlate.position.y = 0.15;
            group.add(upperPlate);

            // Lower arch
            const lowerArchCurve = new THREE.EllipseCurve(
                0, 0, 1.1, 0.85, 0, Math.PI, false, 0
            );

            // Create lower teeth
            const lowerTeethPositions = [
                { x: -0.12, z: 0.95, width: 0.20, height: 0.30 },
                { x: 0.12, z: 0.95, width: 0.20, height: 0.30 },
                { x: -0.38, z: 0.93, width: 0.21, height: 0.30 },
                { x: 0.38, z: 0.93, width: 0.21, height: 0.30 },
                { x: -0.68, z: 0.87, width: 0.22, height: 0.35 },
                { x: 0.68, z: 0.87, width: 0.22, height: 0.35 },
                { x: -0.92, z: 0.70, width: 0.24, height: 0.30 },
                { x: 0.92, z: 0.70, width: 0.24, height: 0.30 },
                { x: -1.05, z: 0.48, width: 0.24, height: 0.30 },
                { x: 1.05, z: 0.48, width: 0.24, height: 0.30 },
                { x: -1.1, z: 0.2, width: 0.26, height: 0.28 },
                { x: 1.1, z: 0.2, width: 0.26, height: 0.28 }
            ];

            lowerTeethPositions.forEach(pos => {
                const tooth = createTooth(pos.width, pos.height, toothMaterial);
                tooth.position.set(pos.x, -0.5, pos.z);
                group.add(tooth);
            });

            // Lower retainer plate
            const lowerPlateGeometry = new THREE.ExtrudeGeometry(
                new THREE.Shape(lowerArchCurve.getPoints(50)),
                {
                    depth: 0.1,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 3
                }
            );
            const lowerPlate = new THREE.Mesh(lowerPlateGeometry, retainerMaterial);
            lowerPlate.rotation.x = -Math.PI / 2;
            lowerPlate.position.y = -0.65;
            group.add(lowerPlate);

            // Retainer wire
            const wirePoints = [];
            const wireSegments = 50;
            for (let i = 0; i <= wireSegments; i++) {
                const t = i / wireSegments;
                const angle = Math.PI * t;
                const x = Math.cos(angle) * 1.15;
                const z = Math.sin(angle) * 0.88;
                wirePoints.push(new THREE.Vector3(x, 0.45, z));
            }
            const wireGeometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(wirePoints),
                64, 0.015, 8, false
            );
            const wire = new THREE.Mesh(wireGeometry, wireMaterial);
            group.add(wire);

            // Direction indicator arrow
            const arrowGeometry = new THREE.ConeGeometry(0.12, 0.4, 8);
            const arrowMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                emissive: 0xff0000,
                emissiveIntensity: 0.4
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.position.set(0, 0.3, 1.5);
            arrow.rotation.x = Math.PI / 2;
            group.add(arrow);

            // Coordinate axes at model origin
            const modelAxes = new THREE.AxesHelper(1.8);
            group.add(modelAxes);

            retainerModel = group;
            scene.add(retainerModel);
        }

        // Create individual tooth
        function createTooth(width, height, material) {
            const toothGroup = new THREE.Group();

            const crownGeometry = new THREE.BoxGeometry(width, height, 0.25);
            const crown = new THREE.Mesh(crownGeometry, material);
            crown.castShadow = true;
            toothGroup.add(crown);

            const topGeometry = new THREE.SphereGeometry(
                width * 0.5, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2
            );
            const top = new THREE.Mesh(topGeometry, material);
            top.position.y = height / 2;
            top.scale.set(1, 0.3, 0.6);
            toothGroup.add(top);

            return toothGroup;
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);

            // Update FPS counter
            const now = Date.now();
            if (now - lastUpdateTime >= 1000) {
                fps = updateCount;
                document.getElementById('fps').textContent = fps + ' Hz';
                updateCount = 0;
                lastUpdateTime = now;
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        /**
         * Update retainer orientation from quaternion
         * IMPROVED: Proper coordinate system mapping
         * 
         * IMU Coordinate System (when placed as described):
         *   X-axis: Right (positive to the right)
         *   Y-axis: Up (positive upward)
         *   Z-axis: Forward (positive toward user)
         * 
         * Three.js Coordinate System:
         *   X-axis: Right
         *   Y-axis: Up
         *   Z-axis: Forward (toward camera)
         * 
         * The coordinate systems align, so we apply quaternion directly
         */
        function updateRetainerOrientation(q) {
            if (!retainerModel) return;

            // Apply quaternion directly (coordinate systems align)
            // Note: Three.js quaternion constructor is (x, y, z, w)
            retainerModel.quaternion.set(q.x, q.z, -q.y, q.w);
            
            updateCount++;
        }

        // BLE Connection
        async function connectBLE() {
            try {
                statusDiv.textContent = 'üîµ Connecting...';
                statusDiv.classList.add('pulse');

                bleDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'SmartRetainer' }],
                    optionalServices: [IMU_SERVICE_UUID]
                });

                bleDevice.addEventListener('gattserverdisconnected', onDisconnected);

                bleServer = await bleDevice.gatt.connect();
                const service = await bleServer.getPrimaryService(IMU_SERVICE_UUID);

                quaternionCharacteristic = await service.getCharacteristic(QUATERNION_CHAR_UUID);
                eulerCharacteristic = await service.getCharacteristic(EULER_CHAR_UUID);
                controlCharacteristic = await service.getCharacteristic(CONTROL_CHAR_UUID);

                await quaternionCharacteristic.startNotifications();
                quaternionCharacteristic.addEventListener('characteristicvaluechanged', 
                    handleQuaternionData);

                await eulerCharacteristic.startNotifications();
                eulerCharacteristic.addEventListener('characteristicvaluechanged', 
                    handleEulerData);

                statusDiv.textContent = 'üü¢ Connected';
                statusDiv.classList.remove('pulse');
                connectBtn.textContent = 'Disconnect';
                connectBtn.classList.add('connected');
                resetBtn.disabled = false;
                calibrateBtn.disabled = false;

                console.log('BLE connected successfully');

            } catch (error) {
                console.error('BLE connection error:', error);
                statusDiv.textContent = 'üî¥ Connection Failed';
                statusDiv.classList.remove('pulse');
                alert('Failed to connect: ' + error.message);
            }
        }

        function onDisconnected() {
            console.log('BLE disconnected');
            statusDiv.textContent = '‚ö™ Disconnected';
            statusDiv.classList.add('pulse');
            connectBtn.textContent = 'Connect to Device';
            connectBtn.classList.remove('connected');
            resetBtn.disabled = true;
            calibrateBtn.disabled = true;

            bleDevice = null;
            bleServer = null;
            quaternionCharacteristic = null;
            eulerCharacteristic = null;
            controlCharacteristic = null;
        }

        async function disconnectBLE() {
            if (bleDevice && bleDevice.gatt.connected) {
                await bleDevice.gatt.disconnect();
            }
        }

        function handleQuaternionData(event) {
            const value = event.target.value;
            
            // Read quaternion (w, x, y, z) - little endian
            const w = value.getFloat32(0, true);
            const x = value.getFloat32(4, true);
            const y = value.getFloat32(8, true);
            const z = value.getFloat32(12, true);

            currentQuaternion = { w, x, y, z };

            // Update 3D model
            updateRetainerOrientation(currentQuaternion);

            // Update UI
            document.getElementById('qw').textContent = w.toFixed(3);
            document.getElementById('qx').textContent = x.toFixed(3);
            document.getElementById('qy').textContent = y.toFixed(3);
            document.getElementById('qz').textContent = z.toFixed(3);
        }

        function handleEulerData(event) {
            const value = event.target.value;
            
            // Read Euler angles in radians - little endian
            const roll = value.getFloat32(0, true);
            const pitch = value.getFloat32(4, true);
            const yaw = value.getFloat32(8, true);

            // Ê†πÊçÆ3DÊ®°ÂûãÁöÑÂèòÊç¢ËßÑÂàôË∞ÉÊï¥EulerËßíÂ∫¶ÊòæÁ§∫
            // 3DÊ®°Âûã: set(q.x, q.z, -q.y, q.w)
            // ÂØπÂ∫îÂà∞EulerËßíÂ∫¶:
            // - Roll (XËΩ¥): ‰øùÊåÅ‰∏çÂèò (roll)
            // - Pitch (YËΩ¥): ‰ΩøÁî®ÂéüÊù•ÁöÑYawÂÄº (yaw)
            // - Yaw (ZËΩ¥): ‰ΩøÁî®ÂéüÊù•ÁöÑPitchÂÄºÂπ∂ÂèñÂèç (-pitch)
            currentEuler = { 
                roll: -pitch,      // XËΩ¥‰øùÊåÅ‰∏çÂèò
                pitch: yaw,      // ÂéüÊù•ÁöÑyawÂèòÊàêpitch
                yaw:   roll    // ÂéüÊù•ÁöÑpitchÂèñÂèçÂêéÂèòÊàêyaw
            };

            // Convert to degrees
            const rollDeg = (-pitch * 180 / Math.PI).toFixed(1);
            const pitchDeg = (yaw * 180 / Math.PI).toFixed(1);      // ÊòæÁ§∫ÂéüÊù•ÁöÑyawÂÄº
            const yawDeg = (roll * 180 / Math.PI).toFixed(1);     // ÊòæÁ§∫ÂéüÊù•ÁöÑpitchÂÄºÂèñÂèç

            document.getElementById('roll').textContent = rollDeg + '¬∞';
            document.getElementById('pitch').textContent = pitchDeg + '¬∞';
            document.getElementById('yaw').textContent = yawDeg + '¬∞';
        }

        async function sendControlCommand(cmd) {
            if (!controlCharacteristic) {
                alert('Not connected to device');
                return;
            }

            try {
                const data = new Uint8Array([cmd]);
                await controlCharacteristic.writeValue(data);
                console.log('Control command sent:', cmd);
            } catch (error) {
                console.error('Failed to send command:', error);
                alert('Failed to send command: ' + error.message);
            }
        }

        // Event listeners
        connectBtn.addEventListener('click', () => {
            if (bleDevice && bleDevice.gatt.connected) {
                disconnectBLE();
            } else {
                connectBLE();
            }
        });

        resetBtn.addEventListener('click', () => {
            sendControlCommand(0x03); // BLE_IMU_CMD_RESET
        });

        calibrateBtn.addEventListener('click', () => {
            sendControlCommand(0x04); // BLE_IMU_CMD_CALIBRATE
        });

        // Check browser support
        if (!navigator.bluetooth) {
            alert('Web Bluetooth API is not supported in this browser. Please use Chrome, Edge, or Opera.');
            connectBtn.disabled = true;
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initThreeJS();
            console.log('Smart Retainer Visualizer v2.0 initialized');
            console.log('Improvements: Gyro calibration, coordinate system fix');
        });
    </script>
</body>
</html>